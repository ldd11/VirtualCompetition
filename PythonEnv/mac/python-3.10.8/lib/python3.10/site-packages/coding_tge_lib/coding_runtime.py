import asyncio
from datetime import datetime
import nest_asyncio
import websockets
import json
import time


class CodingMessage:
    def __init__(self, id):
        self.id = id
        self.type = 'request'

    def toJSON(self):
        return json.dumps(self, default=lambda o: o.__dict__,
                          sort_keys=False, indent=None)


class CodingRequest(CodingMessage):
    def __init__(self, id, command, args):
        super().__init__(id)
        self.command = command
        self.args = args


class CodingRuntime:
    def __init__(self):
        self.request_seq = 1
        self.request_map = {}
        self.whenMap = {}
        self.url = "ws://localhost:7799/Runtime"
        self.__start()

    def __start(self):
        print("[CodingRuntime] __start")
        # asyncio.ensure_future(self.__connectWS())
        loop.run_until_complete(self.__connectWS())
        # loop.run_forever()

    async def __connectWS(self):
        print("[CodingRuntime] __connectWS: " + self.url)

        self.ws = await websockets.connect(self.url)
        print("[CodingRuntime] __connectWS: " + self.url + " -> connected")
        asyncio.ensure_future(self.__recv(self.ws))
        self.sendRequest("Start", [], True)

    async def __recv(self, websocket):
        async for message in websocket:
            await self.process(message)

    def sendRequest(self, method, args, wait=True):
        loop.run_until_complete(self.__sendRequest(method, args, wait))

    async def __sendRequest(self, method, args, wait=True):
        # print("[CodingRuntime] __sendRequest: " + method + " " + str(args) + " " + str(wait))
        seq = self.request_seq
        await self.__send(CodingRequest(seq, method, args), wait)
        # print("[CodingRuntime] __sendRequest: " + method + " " + str(args) + " " + str(wait) + " -> received response of " + str(seq))

    async def __send(self, message: CodingRequest, wait):
        # push in queue, and pop it later ???? 不能调试
        print("[CodingRuntime] [" + getTimingStr() +
              "] __send -----> " + message.toJSON())
        if wait:
            self.request_map[message.id] = asyncio.Event()

        await self.ws.send(message.toJSON())
        # print("[CodingRuntime] try send id: " + str(message.id))
        self.request_seq += 1
        if wait:
            await self.request_map[message.id].wait()
        print("[CodingRuntime] finally got response to id: " + str(message.id))

    async def process(self, message):
        msg = json.loads(message)

        if msg['type'] == 'response':
            print("[CodingRuntime] [" + getTimingStr() +
                  "] __recv <----- " + message)
            id = msg['req_id']
            if id in self.request_map:
                self.request_map[id].set()
                del self.request_map[id]

        elif msg['type'] == 'event':
            print("[CodingRuntime] [" + getTimingStr() +
                  "] __recv <----- " + message)

        elif msg['type'] == 'sync_data':
            print("[CodingRuntime] [" + getTimingStr() +
                  "] __recv <----- " + message)


def getTiming():
    return datetime.now() - start


def getTimingStr():
    return "{:.2f}".format(getTiming().total_seconds())


print("===================  runtime start ===================")
nest_asyncio.apply()
start = datetime.now()
loop = asyncio.get_event_loop()
runtime = CodingRuntime()
print("Initialize runtime done!")
